package azurerm

/*
Code generated by Microsoft (R) AutoRest Code Generator.
Changes may cause incorrect behavior and will be lost if the code is regenerated.
*/

import (
	"fmt"

	"github.com/Azure/azure-sdk-for-go/services/hdinsight/mgmt/2015-03-01-preview/hdinsight"
	"github.com/hashicorp/terraform/helper/schema"
	"github.com/terraform-providers/terraform-provider-azurerm/azurerm/utils"
)

func resourceArmHDInsightCluster() *schema.Resource {
	return &schema.Resource{
		Create: resourceArmHDInsightClusterCreate,
		Read:   resourceArmHDInsightClusterRead,
		Delete: resourceArmHDInsightClusterDelete,

		Schema: map[string]*schema.Schema{
			"resource_group_name": {
				Type: schema.TypeString,
			},
			"cluster_name": {
				Type: schema.TypeString,
			},
			"parameters": {
				Type: schema.TypeList,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"location": {
							Type: schema.TypeString,
						},
						"tags": {
							Type: schema.TypeMap,
						},
						"properties": {
							Type: schema.TypeList,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"cluster_version": {
										Type: schema.TypeString,
									},
									"os_type": {
										Type: schema.TypeString,
									},
									"tier": {
										Type: schema.TypeString,
									},
									"cluster_definition": {
										Type: schema.TypeList,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"blueprint": {
													Type: schema.TypeString,
												},
												"kind": {
													Type: schema.TypeString,
												},
												"component_version": {
													Type: schema.TypeMap,
												},
											},
										},
									},
									"security_profile": {
										Type: schema.TypeList,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"directory_type": {
													Type: schema.TypeString,
												},
												"domain": {
													Type: schema.TypeString,
												},
												"organizational_unit_dn": {
													Type: schema.TypeString,
												},
												"ldaps_urls": {
													Type: schema.TypeList,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
												"domain_username": {
													Type: schema.TypeString,
												},
												"domain_user_password": {
													Type: schema.TypeString,
												},
												"cluster_users_group_d_ns": {
													Type: schema.TypeList,
													Elem: &schema.Schema{
														Type: schema.TypeString,
													},
												},
											},
										},
									},
									"compute_profile": {
										Type: schema.TypeList,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"roles": {
													Type: schema.TypeList,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type: schema.TypeString,
															},
															"min_instance_count": {
																Type: schema.TypeInt,
															},
															"target_instance_count": {
																Type: schema.TypeInt,
															},
															"hardware_profile": {
																Type: schema.TypeList,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"vm_size": {
																			Type: schema.TypeString,
																		},
																	},
																},
															},
															"os_profile": {
																Type: schema.TypeList,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"linux_operating_system_profile": {
																			Type: schema.TypeList,
																			Elem: &schema.Resource{
																				Schema: map[string]*schema.Schema{
																					"username": {
																						Type: schema.TypeString,
																					},
																					"password": {
																						Type: schema.TypeString,
																					},
																					"ssh_profile": {
																						Type: schema.TypeList,
																						Elem: &schema.Resource{
																							Schema: map[string]*schema.Schema{
																								"public_keys": {
																									Type: schema.TypeList,
																									Elem: &schema.Resource{
																										Schema: map[string]*schema.Schema{
																											"certificate_data": {
																												Type: schema.TypeString,
																											},
																										},
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
															"virtual_network_profile": {
																Type: schema.TypeList,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"id": {
																			Type: schema.TypeString,
																		},
																		"subnet": {
																			Type: schema.TypeString,
																		},
																	},
																},
															},
															"data_disks_groups": {
																Type: schema.TypeList,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"disks_per_node": {
																			Type: schema.TypeInt,
																		},
																		"storage_account_type": {
																			Type: schema.TypeString,
																		},
																		"disk_size_gb": {
																			Type: schema.TypeInt,
																		},
																	},
																},
															},
															"script_actions": {
																Type: schema.TypeList,
																Elem: &schema.Resource{
																	Schema: map[string]*schema.Schema{
																		"name": {
																			Type: schema.TypeString,
																		},
																		"uri": {
																			Type: schema.TypeString,
																		},
																		"parameters": {
																			Type: schema.TypeString,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"storage_profile": {
										Type: schema.TypeList,
										Elem: &schema.Resource{
											Schema: map[string]*schema.Schema{
												"storageaccounts": {
													Type: schema.TypeList,
													Elem: &schema.Resource{
														Schema: map[string]*schema.Schema{
															"name": {
																Type: schema.TypeString,
															},
															"is_default": {
																Type: schema.TypeBool,
															},
															"container": {
																Type: schema.TypeString,
															},
															"key": {
																Type: schema.TypeString,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func resourceArmHDInsightClusterCreate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClusterClient
	ctx := meta.(*ArmClient).StopContext

	name := d.Get("cluster_name").(string)
	resGroup := d.Get("resource_group_name").(string)
	parameters := expandArmClusterCreateParametersExtended(d.Get("parameters").([]interface{}))

	future, err := client.Create(ctx, resGroup, name, *parameters)
	if err != nil {
		return fmt.Errorf("Error Creating/Updating HD Insight Cluster %q (Resource Group %q): %+v", name, resGroup, err)
	}

	err = future.WaitForCompletion(ctx, client.Client)
	if err != nil {
		return fmt.Errorf("Error Creating/Updating HD Insight Cluster %q (Resource Group %q): %+v", name, resGroup, err)
	}

	read, err := client.Get(ctx, resGroup, name)
	if err != nil {
		return fmt.Errorf("Error Retrieving HD Insight Cluster %q (Resource Group %q): %+v", name, resGroup, err)
	}
	if read.ID == nil {
		return fmt.Errorf("Cannot read HD Insight Cluster %q (resource group %q) ID", name, resGroup)
	}

	d.SetId(*read.ID)

	return resourceArmHDInsightClusterRead(d, meta)
}

func resourceArmHDInsightClusterRead(d *schema.ResourceData, meta interface{}) error {
	return nil
}

func resourceArmHDInsightClusterDelete(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*ArmClient).hdInsightClusterClient
	ctx := meta.(*ArmClient).StopContext

	id, err := parseAzureResourceID(d.Id())
	if err != nil {
		return err
	}

	name := id.Path["clusters"]
	resGroup := id.ResourceGroup

	future, err := client.Delete(ctx, resGroup, name)
	if err != nil {
		return fmt.Errorf("Error issuing AzureRM delete request for HD Insight Cluster %q: %+v", name, err)
	}

	err = future.WaitForCompletion(ctx, client.Client)
	if err != nil {
		return fmt.Errorf("Error waiting for the deleting HD Insight Cluster %q (Resource Group %q): %+v", name, resGroup, err)
	}

	return nil
}

func expandArmClusterCreateParametersExtended(u []interface{}) *hdinsight.ClusterCreateParametersExtended {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.ClusterCreateParametersExtended{
		Location:   utils.String(v["location"].(string)),
		Tags:       expandTags(v["tags"].(map[string]interface{})),
		Properties: expandArmClusterCreateProperties(v["properties"].([]interface{})),
	}
}

func expandArmClusterCreateProperties(u []interface{}) *hdinsight.ClusterCreateProperties {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.ClusterCreateProperties{
		ClusterVersion:    utils.String(v["cluster_version"].(string)),
		ClusterDefinition: expandArmClusterDefinition(v["cluster_definition"].([]interface{})),
		SecurityProfile:   expandArmSecurityProfile(v["security_profile"].([]interface{})),
		ComputeProfile:    expandArmComputeProfile(v["compute_profile"].([]interface{})),
		StorageProfile:    expandArmStorageProfile(v["storage_profile"].([]interface{})),
	}
}

func expandArmClusterDefinition(u []interface{}) *hdinsight.ClusterDefinition {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.ClusterDefinition{
		Blueprint:        utils.String(v["blueprint"].(string)),
		Kind:             utils.String(v["kind"].(string)),
		ComponentVersion: expandTags(v["component_version"].(map[string]interface{})),
	}
}

func expandArmSecurityProfile(u []interface{}) *hdinsight.SecurityProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.SecurityProfile{
		Domain:               utils.String(v["domain"].(string)),
		OrganizationalUnitDN: utils.String(v["organizational_unit_dn"].(string)),
		LdapsUrls:            expandArmLdapsUrlsArray(v["ldaps_urls"].([]interface{})),
		DomainUsername:       utils.String(v["domain_username"].(string)),
		DomainUserPassword:   utils.String(v["domain_user_password"].(string)),
		ClusterUsersGroupDNS: expandArmClusterUsersGroupDNsArray(v["cluster_users_group_d_ns"].([]interface{})),
	}
}

func expandArmRole(u []interface{}) *hdinsight.Role {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.Role{
		Name:                  utils.String(v["name"].(string)),
		MinInstanceCount:      utils.Int32(v["min_instance_count"].(int32)),
		TargetInstanceCount:   utils.Int32(v["target_instance_count"].(int32)),
		HardwareProfile:       expandArmHardwareProfile(v["hardware_profile"].([]interface{})),
		OsProfile:             expandArmOsProfile(v["os_profile"].([]interface{})),
		VirtualNetworkProfile: expandArmVirtualNetworkProfile(v["virtual_network_profile"].([]interface{})),
		DataDisksGroups:       expandArmDataDisksGroupsArray(v["data_disks_groups"].([]interface{})),
		ScriptActions:         expandArmScriptActionsArray(v["script_actions"].([]interface{})),
	}
}

func expandArmHardwareProfile(u []interface{}) *hdinsight.HardwareProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.HardwareProfile{
		VMSize: utils.String(v["vm_size"].(string)),
	}
}

func expandArmLinuxOperatingSystemProfile(u []interface{}) *hdinsight.LinuxOperatingSystemProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.LinuxOperatingSystemProfile{
		Username:   utils.String(v["username"].(string)),
		Password:   utils.String(v["password"].(string)),
		SSHProfile: expandArmSshProfile(v["ssh_profile"].([]interface{})),
	}
}

func expandArmSshPublicKey(u []interface{}) *hdinsight.SSHPublicKey {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.SSHPublicKey{
		CertificateData: utils.String(v["certificate_data"].(string)),
	}
}

func expandArmSshProfile(u []interface{}) *hdinsight.SSHProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.SSHProfile{
		PublicKeys: expandArmPublicKeysArray(v["public_keys"].([]interface{})),
	}
}

func expandArmOsProfile(u []interface{}) *hdinsight.OsProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.OsProfile{
		LinuxOperatingSystemProfile: expandArmLinuxOperatingSystemProfile(v["linux_operating_system_profile"].([]interface{})),
	}
}

func expandArmVirtualNetworkProfile(u []interface{}) *hdinsight.VirtualNetworkProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.VirtualNetworkProfile{
		ID:     utils.String(v["id"].(string)),
		Subnet: utils.String(v["subnet"].(string)),
	}
}

func expandArmDataDisksGroups(u []interface{}) *hdinsight.DataDisksGroups {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.DataDisksGroups{
		DisksPerNode:       utils.Int32(v["disks_per_node"].(int32)),
		StorageAccountType: utils.String(v["storage_account_type"].(string)),
		DiskSizeGB:         utils.Int32(v["disk_size_gb"].(int32)),
	}
}

func expandArmScriptAction(u []interface{}) *hdinsight.ScriptAction {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.ScriptAction{
		Name:       utils.String(v["name"].(string)),
		URI:        utils.String(v["uri"].(string)),
		Parameters: utils.String(v["parameters"].(string)),
	}
}

func expandArmComputeProfile(u []interface{}) *hdinsight.ComputeProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.ComputeProfile{
		Roles: expandArmRolesArray(v["roles"].([]interface{})),
	}
}

func expandArmStorageAccount(u []interface{}) *hdinsight.StorageAccount {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.StorageAccount{
		Name:      utils.String(v["name"].(string)),
		IsDefault: utils.Bool(v["is_default"].(bool)),
		Container: utils.String(v["container"].(string)),
		Key:       utils.String(v["key"].(string)),
	}
}

func expandArmStorageProfile(u []interface{}) *hdinsight.StorageProfile {
	if len(u) != 1 {
		return nil
	}
	v := u[0].(map[string]interface{})
	return &hdinsight.StorageProfile{
		Storageaccounts: expandArmStorageaccountsArray(v["storageaccounts"].([]interface{})),
	}
}

func expandArmLdapsUrlsArray(u []interface{}) *[]string {
	v := []string{}
	for _, i := range u {
		v = append(v, i.(string))
	}
	return &v
}

func expandArmClusterUsersGroupDNsArray(u []interface{}) *[]string {
	v := []string{}
	for _, i := range u {
		v = append(v, i.(string))
	}
	return &v
}

func expandArmPublicKeysArray(u []interface{}) *[]hdinsight.SSHPublicKey {
	v := []hdinsight.SSHPublicKey{}
	for _, i := range u {
		v = append(v, *expandArmSshPublicKey(i.([]interface{})))
	}
	return &v
}

func expandArmDataDisksGroupsArray(u []interface{}) *[]hdinsight.DataDisksGroups {
	v := []hdinsight.DataDisksGroups{}
	for _, i := range u {
		v = append(v, *expandArmDataDisksGroups(i.([]interface{})))
	}
	return &v
}

func expandArmScriptActionsArray(u []interface{}) *[]hdinsight.ScriptAction {
	v := []hdinsight.ScriptAction{}
	for _, i := range u {
		v = append(v, *expandArmScriptAction(i.([]interface{})))
	}
	return &v
}

func expandArmRolesArray(u []interface{}) *[]hdinsight.Role {
	v := []hdinsight.Role{}
	for _, i := range u {
		v = append(v, *expandArmRole(i.([]interface{})))
	}
	return &v
}

func expandArmStorageaccountsArray(u []interface{}) *[]hdinsight.StorageAccount {
	v := []hdinsight.StorageAccount{}
	for _, i := range u {
		v = append(v, *expandArmStorageAccount(i.([]interface{})))
	}
	return &v
}
